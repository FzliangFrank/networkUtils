---
title: "Developint Editing tool"
output: html_document
runtime: shiny 
---
```{r setup}
library(igraph)
library(visNetwork)
library(shinyjs)
devtools::load_all()
```


### Create Object
```{r}
g <- igraph::make_graph(~ A-+B:C,
                        B-+D:E, C-+F:G
)

# g <- igraph::make_tree(30, 3)
g_length <- length(V(g))
e_length <- length(E(g))
V(g)$name <- seq(g_length) |> as.character() |> paste0(".name")
V(g)$attr_1 <- sample(seq(10), g_length, replace = T)
V(g)$attr_2 <- sample(LETTERS, g_length, replace = T)
E(g)$attr1 <- sample(LETTERS, e_length, replace = T)
E(g)$attr2 <- sample(seq(10), e_length, replace = T)
# E(g)$name <- seq(e_length) |> as.character()
E(g)$id <- seq(e_length) |> as.character() |> paste0(".id")
```


### Run Shiny Module Preview
```{r}
mod_visNetworkWrite_ui("id")
# function(input, output, session) {
mod_visNetworkWrite_server("id", reactive(g))
# }
```


### View Origin
```{r}
E(g)$title <- pasteEdgeDetails(g)
V(g)$title <- pasteNodeDetails(g)
visIgraph(g)
```

Okay modify graph is a bit tricky. There are a few concept you need to know. 

## Reactive Value

First is shiny `reactiveValues`. This is the only method that let you write change 
an object (it's sister `reactiveVal` is pretty much useless). 

Object accessed via `reactiveValues$x` will be automatically reactive. Assign is 
allowed so I guess this is some sort of active field. 

## Index Edge

The second concept is igraph operation, igraph vertex indexing. 
```{r}
g <- igraph::make_graph(~ A-+B:C,
                        B-+D:E, C-+F:G
)
# turns out you can subset vertex by just using 
E(g)[.inc("A")] # incident vertex of A
E(g)[.from("A")] # from vertex of A
E(g)[.to("B")] # to vertex of B
E(g)["F" %--% "C"] # edge between F and C
E(g)["A" %->% "B"]

new_g <- g + edge(1, 4)
new_g <- g + edge("A", "G")
visIgraph(new_g)
```

Igraph have "interesting" way of decideing which ones are id which ones are not. 

## `_graphChange$cme == "editEdge"`
This one is really tricky, because you need to find ways to save edge attributes
data and assign it to another way. 

Yet our shiny app track edge id by a randomly assigned uid, **unless you specify 
yourself**. 

Now what happen if we use tidygraph? 
Nope! nothing changes!

if you have both id and name in your igraph? 
For edge, you can only use id.
Apparently it have a preference for col name `id`

What about uid? 
Nope! only recognize `id`

```{r eval = FALSE}

# g - edge("2.id", by = "id") # this won't run
g - edge("2.name", by = "2") # this will
g - edge(2)
g - edge("2")


delete_edges(g, )

get.edge.ids(g, c(1, 2))
E(g)$id
```

Igraph preper edge name over an attribute named id..
But in visIgraph any attribute named `id` or `name` will be interpreated as edge


## Use Binding Reactive Values

```{r eval=FALSE}
library(shiny)

ui <- fluidPage(
  verbatimTextOutput("text"),
  sliderInput("init", "set Initial Value", min = 1, max = 5,value = 2),
  sliderInput("set", "set value b to", min = 1, max = 5,value = 2),
  actionButton("commit", "commit change")
)

server <- function(input, output, session) {
  g <- reactiveValues(a = NULL,
                      b = NULL)
  output$text <- renderPrint({
    print(sprintf("a is: %i", g$a))
    print(sprintf("b is : %i", g$b))
  })
  observe({
    g$a <- input$init
    g$b <- input$init
    print("initial Assignment")
  })
  
  observe({
    g$b <- input$set
  })
  observeEvent(input$commit, {
    g$a <- g$b 
  })
}
shinyApp(ui, server)
```
